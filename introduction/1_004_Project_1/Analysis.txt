Task 0:Runtime: O(1)-	Array access via index has time complexity O(1)The algorithm includes two instructions to get the elements in a Python list. Internally, a Python list is represented as an array and the time complexity to access the elements in an array is O(1).The runtime complexity of this algorithm is roughly therefore: O(1+1) -> O(1)Task 1:Runtime: O(n)-	Set.add(item) has an average time complexity of O(1) -	For-loop over all inputs has a time complexity O(n)The algorithm includes two for-loops to get the elements in the texts and calls lists. The two for-loops include two insertions in a Python set. According to Python-Wiki-Time-complexity, Set is implemented as a hash table. The implementation of the set.add(item) has an average time complexity of O(1). The runtime complexity of this algorithm is therefore: O(n*(1+1) + n*(1+1)) -> O(n)Task 2:Runtime: O(n)The algorithm includes two for-loops.-	For-loop over all inputs has a complexity of O(n)First for-loop: -	Array access via index has time complexity of O(1)-	Adding/setting an element to a dictionary has an average time complexity of O(1) Second for-loop:-	Access an element to a dictionary has an average time complexity of O(1)The time complexity of this algorithm is therefore: O(n)Task 3:Part A:Runtime: O(n*log n)The algorithm has two for-loops.-	For-loop over all inputs has a complexity of O(n)-	Sorting a list has a time complexity of O(n*log n)First for-loop:-	String operation has time complexity of O(1)-	Array access via index has time complexity of O(1)-	Get_area_code(call_number) are string operations with a time complexity of O(1)-	Set.add(item) has an average time complexity of O(1)Second for-loop:-	Printing a string has a time complexity of O(1)The time complexity of this algorithm is therefore: O(n*(1+1+1+1)+n*log n + n) -> O(n*log n)PART B:Runtime: O(n)For-loop:-	String operation has time complexity O(1)-	Incrementing a variable has time complexity of O(1)The time complexity of this algorithm is therefore O(n*(1+1))) -> O(n)Task 4:Runtime: O(n*log n)-	Sorting a list has a time complexity of O(n*log n)-	Printing a list has a time complexity of O(n)Function get_possible_Telemarketers(): O(n)First and second for-loop:-	Array access via index has time complexity O(1)-	Adding an element to a set has an average time complexity of O(1)Third for-loop:-	Checking for existence in a set has an average time complexity of O(1)The time complexity of this algorithm is therefore: O(n + n*log n + n) -> O(n*log n)